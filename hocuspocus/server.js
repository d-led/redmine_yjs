const { Server } = require('@hocuspocus/server');
const crypto = require('crypto');

// No database persistence needed - Redmine stores the final documents
// Hocuspocus only handles ephemeral real-time collaboration during editing

// Fly.io uses PORT env var, Docker Compose uses HOCUSPOCUS_PORT
const port = parseInt(process.env.PORT || process.env.HOCUSPOCUS_PORT || '8081', 10);

// Shared secret for HMAC-signed tokens generated by Redmine.
// When set, all clients MUST present a valid token or the connection is rejected.
// When not set, the server falls back to a weak development-only auth mode.
const tokenSecret = process.env.YJS_TOKEN_SECRET || '';

function verifyToken(token, expectedDocumentName) {
  if (!tokenSecret) {
    return null;
  }

  try {
    const [payloadB64, sigB64] = (token || '').split('.');
    if (!payloadB64 || !sigB64) {
      console.warn('[Hocuspocus] ‚ùå Token missing payload or signature');
      return null;
    }

    const payloadJson = Buffer.from(payloadB64, 'base64url').toString('utf8');
    const givenSig = Buffer.from(sigB64, 'base64url');

    const expectedSig = crypto
      .createHmac('sha256', tokenSecret)
      .update(payloadJson)
      .digest();

    if (
      givenSig.length !== expectedSig.length ||
      !crypto.timingSafeEqual(givenSig, expectedSig)
    ) {
      console.warn('[Hocuspocus] ‚ùå Token signature mismatch');
      return null;
    }

    const payload = JSON.parse(payloadJson);

    if (typeof payload.exp !== 'number' || payload.exp < Math.floor(Date.now() / 1000)) {
      console.warn('[Hocuspocus] ‚ùå Token expired');
      return null;
    }

    if (!payload.doc || payload.doc !== expectedDocumentName) {
      console.warn(
        `[Hocuspocus] ‚ùå Token document mismatch: expected "${expectedDocumentName}", got "${payload.doc}"`
      );
      return null;
    }

    if (!payload.uid) {
      console.warn('[Hocuspocus] ‚ùå Token missing uid');
      return null;
    }

    return payload;
  } catch (error) {
    console.error('[Hocuspocus] ‚ùå Error verifying token:', error);
    return null;
  }
}

// Configure Hocuspocus server as per docs: https://tiptap.dev/docs/hocuspocus/guides/collaborative-editing
// Simple setup - just like the docs!
const server = new Server({
  // No extensions - ephemeral collaboration only, Redmine stores final documents
  timeout: 30000, // 30 second timeout for connections
  
  onUpgrade: async ({ request }) => {
    console.log(`[Hocuspocus] üîÑ onUpgrade hook called: ${request.method} ${request.url}`);
    console.log(`[Hocuspocus] üîÑ Request headers:`, Object.keys(request.headers));
    // Return true to allow the upgrade
    const result = true;
    console.log(`[Hocuspocus] üîÑ onUpgrade returning:`, result);
    return result;
  },
  
  onAuthenticate: async ({ token, documentName }) => {
    if (tokenSecret && token && token.includes('.')) {
      const payload = verifyToken(token, documentName);
      if (!payload) {
        console.warn(`[Hocuspocus] ‚ùå Authentication failed for document: ${documentName}`);
        throw new Error('Unauthorized');
      }

      const user = {
        id: String(payload.uid),
        name: payload.login || String(payload.uid),
      };

      console.log(
        `[Hocuspocus] ‚úÖ Authenticated uid=${user.id} login=${user.name} for document: ${documentName}`
      );
      return { user };
    }

    // Development / misconfiguration fallback: trust plain JSON token from client.
    // This keeps collaboration working even if Redmine is not yet configured to
    // issue signed tokens, but logs a loud warning when a secret is set.
    let user = { id: 'anonymous', name: 'Anonymous' };

    if (token) {
      try {
        const parsed = JSON.parse(token);
        user = {
          id: parsed.id || 'anonymous',
          name: parsed.name || parsed.id || 'Anonymous',
        };
      } catch (e) {
        user = { id: token, name: token };
      }
    }

    if (tokenSecret) {
      console.warn(
        '[Hocuspocus] ‚ö†Ô∏è YJS_TOKEN_SECRET is set but no signed token was provided. Falling back to insecure dev auth ‚Äì check your Redmine configuration.'
      );
    } else {
      console.warn(
        '[Hocuspocus] ‚ö†Ô∏è YJS_TOKEN_SECRET not set, using insecure development auth ‚Äì do not use in production.'
      );
    }
    console.log(
      `[Hocuspocus] ‚úÖ (fallback) Authenticating user: ${user.name} (${user.id}) for document: ${documentName}`
    );
    return { user };
  },
  
  onConnect: async ({ documentName, context }) => {
    const userId = context?.user?.id || 'unknown';
    const userName = context?.user?.name || 'Unknown';
    console.log(`[Hocuspocus] ‚úÖ Client connected - User: ${userName} (${userId}), Document: ${documentName}`);
  },
  
  onDisconnect: async ({ documentName, context }) => {
    const userId = context?.user?.id || 'unknown';
    const userName = context?.user?.name || 'Unknown';
    console.log(`[Hocuspocus] üëã Client disconnected - User: ${userName} (${userId}), Document: ${documentName}`);
  },
  
  // No onLoadDocument/onStoreDocument - ephemeral collaboration only
  // Redmine stores the final documents when users save
});

// Handle WebSocket errors to prevent crashes (see https://github.com/ueberdosis/hocuspocus/issues/392)
server.webSocketServer.on('error', (error) => {
  console.error(`[Hocuspocus] WebSocket server error:`, error);
  // Don't crash - just log the error
});

// Debug: Log all upgrade requests (will be attached after server.listen())

// Start Hocuspocus server
// HocuspocusProvider appends document name to URL: ws://host/ws/document-name
// Traefik forwards /ws/document-name to Hocuspocus
// Hocuspocus extracts document name from path (everything after first /)
server.listen(port).then(() => {
  console.log(`Hocuspocus server listening on port ${port}`);
  console.log(`WebSocket endpoint: ws://0.0.0.0:${port}/document-name (Traefik strips /ws prefix)`);
  console.log(`Mode: Ephemeral collaboration (no persistence - Redmine stores final documents)`);
  
  // Add health check and debug logging to Hocuspocus's HTTP server
  const httpServer = server.httpServer;
  if (httpServer) {
    // Debug: Log all upgrade requests
    httpServer.on('upgrade', (request, socket, head) => {
      console.log(`[Hocuspocus] üîç WebSocket upgrade request: ${request.method} ${request.url}`);
      console.log(`[Hocuspocus] üîç Headers:`, JSON.stringify(request.headers, null, 2));
    });
    
    // Intercept requests to add health check
    const originalEmit = httpServer.emit.bind(httpServer);
    httpServer.emit = function(event, ...args) {
      if (event === 'request') {
        const [req, res] = args;
        if (req.url === '/health') {
          res.writeHead(200, { 'Content-Type': 'text/plain' });
          res.end('OK');
          return true;
        }
      }
      return originalEmit(event, ...args);
    };
    console.log(`Health check: http://0.0.0.0:${port}/health`);
  }
}).catch(console.error);
